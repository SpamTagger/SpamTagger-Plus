#!/usr/bin/env perl

use v5.40;
use warnings;
use utf8;

use lib "__SRCDIR__/lib";
use SMTPAuthenticator;
use SMTPCalloutConnector;

sub hide_token ($dnsname) {
  my $count = $dnsname =~ tr/.//;
  if ($count >= 2 && $dnsname =~ /(([a-zA-Z0-9-_]*\.){2}[a-zA-Z0-9-_]*)\.$/) {
     return $1;
  } else {
     return $dnsname;
  }
}

sub authenticate ($account, $password) {
  my $auth = SMTPAuthenticator::create($account);
  my $ip = Exim::expand_string('$sender_host_address');

  if (!$auth) {
    Exim::log_write("Could not create authenticator for account: $account");
    return 0;
  }

  if ($auth->authenticate($password, $ip)) {
    return 1;
  }
  my $error = $auth->get_error_text();
  return 0;
}

sub auth_log {
  my $text = shift;

  Exim::log_write($text);
}


sub external_callout_verify ($local_part, $domain) {
  my $rcpt = $local_part.'@'.$domain;

  my $connector = SMTPCalloutConnector::create($domain);
  if (!$connector) {
    Exim::log_write("Could not create callout connector for domain: $domain");
    return external_callout_build_return(1, "callout connector cannot be create");
  }

  if (!$connector->verify($rcpt)) {
    if ($connector->last_message() ne '') {
      Exim::log_write("External callout last message for recipient $rcpt: ".$connector->last_message());
    }
    return external_callout_build_return(0, $connector->last_message());
  }

  if ($connector->last_message() ne '') {
    Exim::log_write("External callout last message for recipient $rcpt: ".$connector->last_message());
  }
  return external_callout_build_return(1, $connector->last_message());
}

sub external_callout_build_return ($result, $message) {
  my $str = 'result='.$result;
  $str .= ' message="'.$message.'"';

  return $str;
}

sub smtp_wl_ip_dom ($domain, $IP) {
  my $file = "/var/spamtagger/spool/tmp/exim_stage1/rblwhitelists/$domain";

  return 'false' unless (-e $file );
  my $FH;
  return 'false' unless (open($FH, '<', $file));

  my @IPs = <$FH>;
  close($FH);
  chomp(@IPs);

  use Net::CIDR::Lite;
  my $WhIPs = Net::CIDR::Lite->new();
__IF__ DISABLE_IPV6
__ELSE__
  my $WhIPs6 = Net::CIDR::Lite->new();
__FI__
  foreach (@IPs) {
__IF__ DISABLE_IPV6
__ELSE__
    if ($_ =~ m/:/) {
      eval { $WhIPs6->add_any($_); };
    } else {
__FI__
      eval { $WhIPs->add_any($_); };
__IF__ DISABLE_IPV6
__ELSE__
    }
__FI__
  }

  if (
__IF__ DISABLE_IPV6
__ELSE__
    ( $IP =~ /:/ && WhIPs6->find($IP) ) ||
__FI__
    ( $IP !~ /:/ && $WhIPs->find($IP) ) ) {
    Exim::log_write("IP $IP is whitelisted for $domain (SMTP)");
    return 'true';
  }
  return 'false';
}

sub spamc_wl_ip_dom ($domain, $IP) {
  my $file = "/var/spamtagger/spool/tmp/exim_stage1/spamcwhitelists/$domain";

  return 'false' unless (-e $file));
  my $FH;
  return 'false' unless (open($FH, '<', $file));

  my @IPs = <$FH>;
  close($FH);
  chomp(@IPs);

  use Net::CIDR::Lite;
  my $WhIPs = Net::CIDR::Lite->new();
__IF__ DISABLE_IPV6
__ELSE__
  my $WhIPs6 = Net::CIDR::Lite->new();
__FI__
  foreach (@IPs) {
__IF__ DISABLE_IPV6
__ELSE__
    if ($_ =~ m/:/) {
      eval { $WhIPs6->add_any($_); };
    } else {
__FI__
      eval { $WhIPs->add_any($_); };
__IF__ DISABLE_IPV6
__ELSE__
    }
__FI__
  }

  if (
__IF__ DISABLE_IPV6
__ELSE__
    ( $IP =~ /:/ && WhIPs6->find($IP) ) ||
__FI__
    ( $IP !~ /:/ && $WhIPs->find($IP) ) ) {
    Exim::log_write("IP $IP is whitelisted for $domain (SpamC)");
    return 'true';
  }
  return 'false';
}

sub prevent_domain_from ($domain, $sender_address_domain) {
  return 'true' if ( lc($domain) eq lc($sender_address_domain) );
  return 'false';
}

sub no_caps_in_domain ($sender_address_domain) {
  return 'true' if ( $sender_address_domain =~ m/[A-Z]/ );
  return 'false';
}
